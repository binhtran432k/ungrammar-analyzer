//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `NODE`, `TOKEN`, or `STAR`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    EQ,
    STAR,
    PIPE,
    QUESTION,
    COLON,
    L_PAREN,
    R_PAREN,
    ERROR,
    IDENT,
    STRING,
    WHITESPACE,
    COMMENT,
    #[doc(hidden)]
    __FIRST,
    GRAMMAR,
    NODE,
    LABEL,
    PAREN_RULE,
    NAME,
    NAME_REF,
    TOKEN,
    SEQ_RULE,
    LABELED_RULE,
    ALT_RULE,
    OPT_RULE,
    REP_RULE,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_punct(self) -> bool {
        matches!(self, EQ | STAR | PIPE | QUESTION | COLON | L_PAREN | R_PAREN)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            '=' => EQ,
            '*' => STAR,
            '|' => PIPE,
            '?' => QUESTION,
            ':' => COLON,
            '(' => L_PAREN,
            ')' => R_PAREN,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { [=] => { $ crate :: SyntaxKind :: EQ } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [:] => { $ crate :: SyntaxKind :: COLON } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; }
